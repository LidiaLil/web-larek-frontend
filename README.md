# Проектная работа "Веб-ларек"

План:
1.Используемый стек.
Стек: HTML, SCSS, TS, Webpack

Структура проекта:

- src/ — исходные файлы проекта
- src/components/ — папка с JS компонентами
- src/components/base/ — папка с базовым кодом

Важные файлы:

- src/pages/index.html — HTML-файл главной страницы
- src/types/index.ts — файл с типами
- src/index.ts — точка входа приложения
- src/scss/styles.scss — корневой файл стилей
- src/utils/constants.ts — файл с константами
- src/utils/utils.ts — файл с утилитами

  2.Инструкция по сборке и запуску.

## Установка и запуск

Для установки и запуска проекта необходимо выполнить команды

```
npm install
npm run start
```

или

```
yarn
yarn start
```

## Сборка

```
npm run build
```

или

```
yarn build
```

3.Описание базовых классов, их предназначение и функции. Опционально — приложить к проекту UML-схему.
// Полное описание товара, полученное с API
interface IItem {
id: string;//идентификатор
description: string;//описание
image: string;//фото
title: string;//навание
category: string;//категория
price: number | null; // если не указана, то null
}

// Данные о заказе, которые отправляются на сервер
interface IOrder {
payment: 'card' | 'cash' | '';//картой, при получении и если не выбрано
email: string;//эмайл
phone: string;//телефон
address: string;//адрес
total: number; // Сумма заказа
items: string[]; // Массив ID товаров
}

// Базовый класс для работы с API
export class Api {
readonly baseUrl: string; // Базовый URL API
protected options: RequestInit; // Настройки запросов по умолчанию

    // Конструктор класса
    constructor(baseUrl: string, options: RequestInit = {}) {
        this.baseUrl = baseUrl;
        this.options = {
            headers: {
                'Content-Type': 'application/json', // Устанавливаем JSON-заголовок
                ...(options.headers as object ?? {}) // Добавляем пользовательские заголовки
            }
        };
    }
    }

Архитектура приложения

Код приложения разделен на слои согласно парадигме MVP

1. Model (Модель) - Слой данных и бизнес-логики
   Что относится к Модели:

AppApi (наследуется от Api): Отвечает исключительно за общение с сервером (GET/POST запросы). Инкапсулирует логику преобразования данных (например, добавление cdn к URL изображений).

BasketModel: Управляет состоянием корзины. Содержит методы для добавления, удаления товаров, подсчета суммы и количества. Это ядро бизнес-логики корзины.

AppState: Предназначен для хранения глобального состояния приложения (например, списка всех товаров items).

CardsModal: Выполняет роль модели для каталога товаров. Хранит загруженные с сервера товары и уведомляет систему об их изменении.

Принципы:

Модели не знают о существовании View.

Они изменяют своё состояние и уведомляют о этом через систему событий EventEmitter. Его функции: возможность установить и снять слушателей событий, вызвать слушателей при возникновении события».
Основные методы, реализуемые классом описаны интерфейсом `IEvents`:

- `on` - подписка на событие
- `emit` - инициализация события
- `trigger` - возвращает функцию, при вызове которой инициализируется требуемое в параметрах событие

2. View (Представление) - Слой отображения
   Что относится к View:
   Все классы, наследуемые от Component:

CardView: Отображает карточку товара в каталоге и в превью. Пассивно слушает клики и транслирует их в виде событий (например, 'add').

BasketView: Отображает содержимое корзины (список товаров, общую сумму, кнопку оформления). Получает готовые HTML-элементы товаров от "Презентера" и просто отображает их.

Header: Отображает иконку корзины и счетчик товаров в ней.

Gallery: Контейнер для отображения каталога карточек товаров.

Modal: Универсальное модальное окно. Умеет показывать и скрывать любой переданный ему контент.

Order и Contacts (наследуются от Form): Представляют собой формы ввода данных. Их главная задача — отобразить поля, собрать данные с них и отправить событие о submit.

Принципы:

View — "глупые" компоненты. Они не знают, откуда берутся данные.

Их задачи: отрисовать то, что им передали, и сообщить о действиях пользователя (клики, ввод данных) через события.

3. Presenter (Посредник) - Слой-оркестратор
   Роль Презентера выполняет файл index.ts.

Это ключевое наблюдение. Вместо выделения отдельных Presenter-классов для каждой View, используетьсяглавный контроллер (или "корневой презентер"), который связывает всё воедино через подписку на события.
